from typing import List, Optional, Dict
import logging
from sqlalchemy import Table, Column, String, MetaData

from uno.db.config import ConnectionConfig
from uno.db.engine.sync import SyncEngineFactory, sync_connection
from uno.settings import uno_settings
from uno.errors import UnoError

# Import the refactored classes
from uno.sql.classes import (
    SQLEmitter, 
    SQLConfig, 
    SQLStatement,
    SQLStatementType, 
    SQLFunctionBuilder,
    SQLTriggerBuilder,
    SQLConfigRegistry
)

# Example implementation of a custom SQLEmitter
class RecordUserAuditFunction(SQLEmitter):
    """Emits SQL for tracking user changes on records."""
    
    def generate_sql(self) -> List[SQLStatement]:
        """Generate SQL for user audit tracking functions and triggers."""
        statements = []
        
        # Get schema and table information
        schema = self.connection_config.db_schema
        table_name = self.table.name
        
        # Build the audit function using the builder pattern
        function_body = """
        DECLARE
        BEGIN
            -- Update the modified_by field with the current user
            NEW.modified_by = (SELECT current_setting('app.current_user', TRUE));
            RETURN NEW;
        END;
        """
        
        function_sql = (
            SQLFunctionBuilder()
            .with_schema(schema)
            .with_name(f"{table_name}_audit_user_function")
            .with_return_type("TRIGGER")
            .with_body(function_body)
            .build()
        )
        
        # Create a SQL statement with metadata
        statements.append(SQLStatement(
            name=f"{table_name}_audit_user_function",
            type=SQLStatementType.FUNCTION,
            sql=function_sql
        ))
        
        # Build the trigger using the builder pattern
        trigger_sql = (
            SQLTriggerBuilder()
            .with_schema(schema)
            .with_table(table_name)
            .with_name(f"{table_name}_audit_user_trigger")
            .with_function(f"{table_name}_audit_user_function")
            .with_timing("BEFORE")
            .with_operation("INSERT OR UPDATE")
            .with_for_each("ROW")
            .build()
        )
        
        # Create a SQL statement with metadata and dependency
        statements.append(SQLStatement(
            name=f"{table_name}_audit_user_trigger",
            type=SQLStatementType.TRIGGER,
            sql=trigger_sql,
            depends_on=[f"{table_name}_audit_user_function"]
        ))
        
        return statements

# Example implementation of a custom SQLEmitter
class ValidateAccountInsert(SQLEmitter):
    """Validates account records on insert."""
    
    def generate_sql(self) -> List[SQLStatement]:
        """Generate validation SQL for account insertions."""
        statements = []
        
        # Get schema and table information
        schema = self.connection_config.db_schema
        table_name = self.table.name
        
        # Build the validation function
        function_body = """
        DECLARE
            account_exists BOOLEAN;
        BEGIN
            -- Check if account with same name already exists
            SELECT EXISTS (
                SELECT 1 FROM {schema}.{table_name} 
                WHERE name = NEW.name AND tenant_id = NEW.tenant_id
            ) INTO account_exists;
            
            IF account_exists THEN
                RAISE EXCEPTION 'Account with name % already exists for this tenant', NEW.name;
            END IF;
            
            RETURN NEW;
        END;
        """.format(schema=schema, table_name=table_name)
        
        function_sql = (
            SQLFunctionBuilder()
            .with_schema(schema)
            .with_name(f"{table_name}_validate_insert")
            .with_return_type("TRIGGER")
            .with_body(function_body)
            .build()
        )
        
        statements.append(SQLStatement(
            name=f"{table_name}_validate_insert_function",
            type=SQLStatementType.FUNCTION,
            sql=function_sql
        ))
        
        #