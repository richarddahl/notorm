# SQL Generation Overview

The SQL Generation layer in uno provides a powerful system for generating SQL statements for database objects, including tables, functions, triggers, and grants.

## SQL Emitters

SQL emitters are components that generate SQL statements for various database objects. They provide a clean interface for generating SQL that is specific to PostgreSQL features.

### BaseEmitter

The `BaseEmitter` class is the foundation for all SQL emitters. It provides common functionality for SQL generation:

```python
from uno.sql.emitter import BaseEmitter

class CustomEmitter(BaseEmitter):```

def __init__(self, model):```

super().__init__()
self.model = model
```
``````

```
```

def emit(self):```

"""Generate SQL for the model."""
return f"-- SQL for {self.model.__tablename__}"
```
```
```

### TableEmitter

The `TableEmitter` generates SQL statements for creating tables:

```python
from uno.sql.emitters.table import TableEmitter

# Generate SQL for creating a table
emitter = TableEmitter(model=CustomerModel)
sql = emitter.emit()
```

The generated SQL will include:

- Primary key definitions
- Column types and constraints
- Indices
- Foreign keys
- Comments

### FunctionEmitter

The `FunctionEmitter` generates SQL statements for creating functions:

```python
from uno.sql.emitters.function import FunctionEmitter

# Define function parameters
params = [```

{"name": "customer_id", "type": "TEXT"},
{"name": "new_status", "type": "TEXT"}
```
]

# Define function body
body = """
UPDATE customer
SET status = new_status
WHERE id = customer_id;
RETURN 1;
"""

# Generate SQL for creating a function
emitter = FunctionEmitter(```

name="update_customer_status",
params=params,
return_type="INTEGER",
body=body,
language="plpgsql"
```
)

sql = emitter.emit()
```

### TriggerEmitter

The `TriggerEmitter` generates SQL statements for creating triggers:

```python
from uno.sql.emitters.trigger import TriggerEmitter

# Generate SQL for creating a trigger
emitter = TriggerEmitter(```

name="customer_update_trigger",
table="customer",
events=["INSERT", "UPDATE"],
timing="AFTER",
function="log_customer_changes",
for_each="ROW"
```
)

sql = emitter.emit()
```

### SecurityEmitter

The `SecurityEmitter` generates SQL statements for security-related operations, such as row-level security policies:

```python
from uno.sql.emitters.security import SecurityEmitter

# Generate SQL for creating a security policy
emitter = SecurityEmitter(```

table="customer",
policy_name="customer_access_policy",
using_expr="(user_id = current_user_id())",
check_expr="(user_id = current_user_id())"
```
)

sql = emitter.emit()
```

### GrantsEmitter

The `GrantsEmitter` generates SQL statements for granting permissions:

```python
from uno.sql.emitters.grants import GrantsEmitter

# Generate SQL for granting permissions
emitter = GrantsEmitter(```

table="customer",
privileges=["SELECT", "INSERT", "UPDATE"],
roles=["app_user", "app_admin"]
```
)

sql = emitter.emit()
```

## Emission Registry

The `EmissionRegistry` class registers and manages SQL emitters:

```python
from uno.sql.registry import EmissionRegistry

# Create a registry
registry = EmissionRegistry()

# Register emitters
registry.register_emitter("table", TableEmitter)
registry.register_emitter("function", FunctionEmitter)
registry.register_emitter("trigger", TriggerEmitter)

# Get an emitter
table_emitter = registry.get_emitter("table")
```

## SQL Statements

The `SQLStatement` class represents a SQL statement with parameters:

```python
from uno.sql.statement import SQLStatement

# Create a SQL statement
statement = SQLStatement(```

text="SELECT * FROM customer WHERE id = :id",
params={"id": "abc123"}
```
)

# Execute the statement
result = await statement.execute(connection)
```

## Best Practices

1. **Use Emitters**: Use the provided emitters for generating SQL rather than writing it manually.

2. **Register Custom Emitters**: Register custom emitters for specific SQL generation needs.

3. **Use Parameters**: Always use parameterized statements to prevent SQL injection.

4. **Leverage PostgreSQL Features**: Take advantage of PostgreSQL-specific features like JSON functions, row-level security, and triggers.

5. **Test Generated SQL**: Test the SQL generated by emitters to ensure it's correct.

## Next Steps

- [SQL Emitters](emitters.md): Learn more about specific SQL emitters
- [SQL Statement](statement.md): Understand the SQL statement class
- [Emission Registry](registry.md): Learn about the emission registry
