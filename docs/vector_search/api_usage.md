# Using Vector Search APIs

This guide demonstrates how to use the vector search APIs in the uno Framework.

## Overview

The vector search functionality is available through:

1. **Python API**: For use in your application code
2. **FastAPI Endpoints**: For HTTP access
3. **SQL Functions**: For direct database access

## Python API

### Service Provider Approach

The recommended way to access vector search is through the service provider pattern:

```python
from uno.dependencies import get_service_provider

# Get the service provider
provider = get_service_provider()

# Get a vector search service for documents
document_search = provider.get_vector_search_service(```

entity_type="document",
table_name="documents"
```
)

# Define a query
class SearchQuery:```

def __init__(self, query_text, limit=10, threshold=0.7):```

self.query_text = query_text
self.limit = limit
self.threshold = threshold
self.metric = "cosine"
```
``````

```
```

def model_dump(self):```

return {
    "query_text": self.query_text,
    "limit": self.limit,
    "threshold": self.threshold,
    "metric": self.metric
}
```
```

# Perform a vector search
query = SearchQuery("How do I reset my password?")
results = await document_search.search(query)

# Process the results
for result in results:```

print(f"ID: {result.id}, Similarity: {result.similarity}")
print(f"Title: {result.entity.title}")
print(f"Content snippet: {result.entity.content[:100]}...")
print()
```
```

### Hybrid Search Example

```python
# Set up graph traversal parameters
start_node_id = "user-123"
max_hops = 2

# Use hybrid search to combine graph and vector
results = await document_search.hybrid_search(```

query=SearchQuery("How do I reset my password?"),
start_id=start_node_id,
max_hops=max_hops
```
)

# Results will prioritize documents that are both semantically similar
# and connected in the graph database
```

### RAG (Retrieval-Augmented Generation)

```python
from uno.dependencies import get_service_provider

# Get the service provider
provider = get_service_provider()

# Get document search service
document_search = provider.get_vector_search_service(```

entity_type="document",
table_name="documents"
```
)

# Get RAG service
rag_service = provider.get_rag_service(document_search)

# Create a full prompt with context
prompt_with_context = await rag_service.create_rag_prompt(```

query="How do I reset my password?",
system_prompt="You are a helpful assistant.",
limit=5,
threshold=0.7
```
)

# The prompt_with_context contains both system_prompt and user_prompt
# where user_prompt includes the original query plus retrieved context
print(prompt_with_context["system_prompt"])
print(prompt_with_context["user_prompt"])

# Send this to your LLM service
# response = await llm_service.generate(prompt_with_context)
```

## Adding New Documents

```python
from uno.dependencies import get_service_provider
from uno.database.db import UNODB

# Get database instance
db = UNODB()

# Insert a new document
document_id = await db.insert(```

"documents",
{```

"title": "Password Reset Guide",
"content": "This guide explains how to reset your password...",
"metadata": {"category": "help", "tags": ["password", "security"]}
```
}
```
)

# The embedding will be automatically generated by database triggers
# No need to manually create or update vectors
```

## FastAPI Endpoints

The framework provides FastAPI endpoints for vector search:

### Configuration Endpoint

```
GET /api/vector/config
```

Returns vector search configuration:
```json
{
  "default_dimensions": 1536,
  "default_index_type": "hnsw",
  "vectorizable_entities": ["documents", "products"]
}
```

### Search Endpoint

```
POST /api/vector/search/documents

{
  "query": "How do I reset my password?",
  "limit": 10,
  "threshold": 0.7,
  "metric": "cosine" 
}
```

Returns search results:
```json
[
  {```

"id": "01HN6J4ZQYF0VEWX13DC7SBRJK",
"similarity": 0.89,
"title": "Password Reset Guide",
"content": "This guide explains how to reset your password...",
"metadata": {
  "category": "help",
  "tags": ["password", "security"]
}
```
  },
  ...
]
```

### Hybrid Search Endpoint

```
POST /api/vector/hybrid/documents

{
  "query": "How do I reset my password?",
  "limit": 10,
  "threshold": 0.7,
  "start_id": "user-123",
  "max_hops": 2
}
```

Returns hybrid search results with both similarity and graph distance.

## Direct SQL Access

You can use the SQL functions directly for maximum flexibility:

```sql
-- Generate an embedding
SELECT uno.generate_embedding('How do I reset my password?');

-- Perform a vector search
SELECT * FROM uno.vector_search(```

'documents',
uno.generate_embedding('How do I reset my password?'),
'embedding',
10,
0.7,
'metadata->>''category'' = ''help'''
```
);

-- Perform a hybrid search
SELECT * FROM uno.hybrid_search(```

'documents',
uno.generate_embedding('How do I reset my password?'),
'SELECT id::TEXT, distance FROM ag_catalog.cypher(''graph'', ```

''MATCH p = (start)-[*1..2]->(v) 
WHERE id(start) = $1 
RETURN id(v) AS id, length(p) AS distance'', ''user-123'')',
```
'embedding',
10,
0.7
```
);
```

## Working with Custom Entity Types

You can register custom entity types for vector search:

```python
from uno.dependencies import get_service_provider

# Get vector config service
provider = get_service_provider()
vector_config = provider.get_vector_config()

# Register a custom entity type
vector_config.register_vectorizable_entity(```

entity_type="product",
fields=["name", "description", "features"],
dimensions=1536,
index_type="hnsw"
```
)

# Create a table for this entity with vector column
# This would typically be in your SQL migrations
sql = """
CREATE TABLE uno.products (```

id TEXT PRIMARY KEY DEFAULT uno.gen_ulid(),
name TEXT NOT NULL,
description TEXT NOT NULL,
features TEXT NOT NULL,
price NUMERIC(10,2) NOT NULL,
metadata JSONB DEFAULT '{}',
created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
embedding vector(1536)
```
);

-- Add embedding trigger
SELECT uno.create_embedding_trigger(```

'products',
'embedding',
ARRAY['name', 'description', 'features'],
1536
```
);

-- Create HNSW index
SELECT uno.create_hnsw_index('products', 'embedding');
"""

# Get the product search service
product_search = provider.get_vector_search_service(```

entity_type="product",
table_name="products"
```
)
```

## Performance Tips

1. **Use appropriate index type**:
   - HNSW for fast search, less frequent updates
   - IVF-Flat for balanced performance

2. **Choose appropriate dimensions**:
   - 1536 for OpenAI Ada 2 embeddings
   - 384 for smaller/faster embedding models

3. **Use batch operations** for bulk updates:
   ```python
   batch_service = provider.get_batch_vector_update_service()
   result = await batch_service.update_entities_by_ids(```

   entity_type="document",
   entity_ids=["doc1", "doc2", "doc3"],
   content_fields=["title", "content"]
```
   )
   ```

4. **Tune threshold values** based on your use case:
   - Higher threshold (0.8-0.9): Higher precision, fewer results
   - Lower threshold (0.5-0.7): Higher recall, more results